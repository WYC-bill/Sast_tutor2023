# 线性表（三）排序

## 一、基本概念

### 1. 排序

​		简单地说，排序就是将一组杂乱无章的数据按一定的规律顺次排列起来。

​		设含有n个元素的序列为 {$R_{[0]}$，$R_{[1]}$，...，$R_{[n-1]}$}，其相应的**关键字序列**为 {$K_{[0]}$，$K_{[1]}$，...，$K_{[n-1]}$}。所谓排序，就是确定一种**排列**（对应关系） $p_{[0]}$，$p_{[1]}$，...，$p_{[n-1]}$，使个关键字满足如下**非递减**（或**非递增**）关系：

​$$K_{[p[0]]}\leq K_{[p[1]]}\leq ··· \leq K_{[p[n-1]]}$$ 或者

​$$K_{[p[0]]}\geq K_{[p[1]]}\geq ··· \geq K_{[p[n-1]]}$$

​		在下面的讨论中，不失一般性地将排序的目标设定为自小到大有序。

### 2. 其他概念

#### 排序算法的 **稳定性**：

​		如果在待排序序列中存在任意两个元素 $R_{[i]}$ 和 $R_{[j]}$，它们的**关键字 $K_{[i]}$ 和 $K_{[j]}$ 相等**，如果能确保排序前后二者的前后顺序关系**保持不变**，则称这种排序方法是稳定的，否则称这种排序方法是不稳定的。

#### **逆序**：

​		待排序序列中如果有两个数据元素的顺序不符合排序的要求，则称为**一个逆序**，逆序也叫倒置。

### 3. 排序算法的评价

#### **时间开销**

​		排序算法的时间开销一般通过数据之间的**比较次数**和数据的**移动次数**进行衡量。一般按照平均情况进行估算；一些受序列初始情况影响较大的算法，也会按照最好和最坏情况进行估算。

#### **（额外）空间开销**

​		排序算法的额外空间开销主要分为三种：规模很小的堆栈或表；链表、指针、数据索引；开辟额外的空间存储数据的副本。这三种空间开销的成本逐渐上升。

## 二、基本排序方法

### 1. 排序算法用到的基本函数

​		在后面的排序算法中，会用到这两种基本的比较和交换函数。

#### 交换

```c++
//交换操作
template<class T>
inline void exch(T* e1, T* e2)
{
	T tmp;
	tmp = *e1;
	*e1 = *e2;
	*e2 = tmp;
}
```

#### 比较-交换（先比较，再交换）

```c++
//比较-交换操作，保证二元组从小到大有序
template<class T>
bool compExch(T* e1, T* e2)
{
	if (*e1 > *e2) {
		exch(e1, e2); return true;
	}
	else return false;
}
```

### 2. 冒泡排序

​		冒泡排序一般是我们接触到的第一种排序算法，但实际上它的思路并不那么直接。基本的想法是将整个排序过程分成数次 **“冒泡”**，每一次“冒泡”实现将无序部分中最小的一个移动到有序部分的最后。具体来讲，从后向前，比较 **相邻** 的两个元素的关键字，如果不符合排序要求，就交换，直到来到无序序列的开头。这样，有序序列逐渐增长，无序序列逐渐缩短，最终使整个序列有序。

```c++
template<class T>
void bubble_sort(T* a, int left, int right)//对第left+1到第right+1个元素进行排序
{
	int i, j;
	for (i = left; i < right; i++)//一共进行n-1趟冒泡，这是第i次冒泡
	{
		for (j = right; j > i; j--)//第i次冒泡要进行n-i次比较和交换操作
		{
			compExch(a + j - 1, a + j);
		}
	}
}
```

​		在基本的冒泡排序中，比较操作无论如何都是 $\frac{n\times(n-1)}{2}$ 次，交换操作在最坏情况下是 $\frac{n\times(n-1)}{2}$ 次。所以冒泡排序是 $O(n^2)$ 的。实际上，如果我们注意到某一次冒泡过程中没有发现逆序，序列已经有序，就可以省去接下来的比较操作，进一步提高效率。

```c++
//经过改进的冒泡排序
template<class T>
void bubble_sort_improved(T* a, int left, int right)//对第left+1到第right+1个元素进行排序
{
	int i, j;
	for (i = left; i < right; i++)//n-1趟冒泡，第i次冒泡
	{
		int flag = false;
		for (j = right; j > i; j--)//第i次冒泡要进行n-i次比较和交换操作
		{
			if (compExch(a + j - 1, a + j))//如果发现有逆序，将标志置为true
			{
				flag = true;
			}
		}
		if (flag == false)return;//如果这一趟冒泡没有逆序，返回
	}
}
```

### 3.插入排序

​		插入排序的思路很容易理解。想象你在和朋友玩扑克牌，在起牌的时候，你需要把一张张无序地来到你手里的牌有序地归纳。大多数人采取的方法是“插入”：每当一张牌到来，比较它和手中目前有的牌，插到使序列有序的位置。这样，手中的牌一直保持有序，起牌结束，排序也就完成了。

​		具体来讲，插入排序又可以分为直接插入、折半插入和希尔排序（缩小增量排序）三种。

#### **直接插入**

​		直接插入排序直接实现了上面描述的思路。将序列分为前面的有序部分和后面的无序部分。每一次插入排序，无需部分的第一个逐个和它前面的元素比大小，直到找到合适的位置，进行交换。

​		另外，需要额外注意两点：一是插入前需要进行 **一次冒泡操作**，将最小的元素放在最前面。若非，当我们拿着最小的元素向前寻找位置插入时会发生溢出；二是交换位置发生在最后一步。如果当前元素比有序序列中的某一个元素小，那么有序序列元素后移，直到确定位置，停止后移，将当前元素插入。

```c++
template<class T>
void insert_sort(T* a, int left, int right)
{
	int i, j;
	T tTag;
	for (i = right; i > left; i--)//一次冒泡，将最小的元素放在最前面，避免负溢
	{
		if (a[i - 1] > a[i])exch(a + i - 1, a + i);
	}
	for (i = left + 2; i <= right; i++)//表示本次进行插入操作的元素下标
	{
		j = i;//记录位置
		tTag = a[i];//记录元素大小
		while (tTag < a[j - 1])//如果满足，此处不是插入位置，再往前寻找小于或等于tTag的位置
		{
			a[j] = a[j - 1];//挪位置
			j--;
		}
		a[j] = tTag;//插入
	}
}
```

​		直接插入排序在最好情况，也就是排序前有序的情况下需要n-1次比较和0次半交换。最坏情况，也就是排序前逆序的情况下需要 $\frac{n\times(n-1)}{2}$ 次比较、半交换，平均下来在 $\frac{n^2}{4}$ 水平，时间复杂度为 $O(n^2)$.

#### **折半插入**

​		折半插入主要修改直接插入排序的寻找插入位置的过程。折半插入利用折半查找寻找插入位置。这一改动使比较次数的复杂度降为 $nlog_2n$，而对交换次数没有改进。由于采用折半查找，在最好情况下（序列初始有序），其性能不如直接插入，但是其最坏情况和平均情况好于直接插入。

```c++
​template<class T>
void insert_bisort(T* a, int l, int r)
{
	int i, j, right, left, middle;
	T e;
	for (i = l + 1; i <= r; i++)
	{
		e = a[i];//当前插入的元素
		left = l; right = i - 1;//折半查找范围
		while (left <= right)//折半查找
		{
			middle = (left + right) / 2;//中间位置
			if (e < a[middle])right = middle - 1;
			else left = middle + 1;
		}//确定插入位置
		for (j = i - 1; j >= left; j--)a[j + 1] = a[j];//成块向后移动，空出插入位置
		a[left] = e;//插入
	}
}
```

#### **希尔排序（缩小增量排序）**

​		如果序列中间距为h的元素（构成的子序列）有序，那么就称这个序列为 **h-排序** 的。在希尔排序中，我们设计 **步长序列**  $h_0$,$h_1$ ,……, $h_n$，其中 $h_0$ =1；第i步排序后序列为 $h_{n+1-i}$ -排序的，进行完第n+1步后排序完成。在每一步希尔排序中，我们都对间距为h的子序列进行直接插入排序。

​		仔细考察希尔排序会发现，在最后一定会进行一次直接插入排序（ $h_0$ =1）。那么为什么希尔排序相较直接插入排序会有效率的提升？原因是开始时 $h_i$ 较大，子序列较短，排序速度快；后期 $h_i$ 减小，但由于前面的工作基础，子序列中大多数序列已经有序，**接近直接排序情况下的最好情况**。

```c++
template<class T>
void shell_sort(T* a, int left, int right)
{
	int shellh[3] = { 1, 2, 5 };
	for (int i = 2; i >= 0; i--)//选择本次排序的gap
	{
		int gap = shellh[i];
			for (int j = left; j < left+gap; j++)//分为gap个组，组内进行直接插入排序
			{
				for (int k = j + gap; k <= right; k += gap)//直接插入排序
				{
					T temp = a[k];
					int s = k - gap;
					while (s >= left && temp < a[s])//s>=left避免负溢
					{
						a[s + gap] = a[s];
						s -= gap;
					}
					a[s + gap] = temp;
				}
			}
	}
}
```

​		希尔排序需要注意步长序列的选择，不要出现循环重复的情况。例如一个好的步长序列可以是：$h_i=4^i+3*2^{i-1}+1$；一个不好的步长序列是：$h_i=2^i$。

### 4.选择排序

​		选择排序的想法也很直观，其将序列分成有序和无序两个部分，每次排序过程，从无序序列中**选择关键字最小的元素**（“打擂台”方法）。记录下其下标后，**和无序序列的第一个元素交换位置**，这样有序序列的长度就增加1，无序序列的长度就减小1。一直进行下去，直到整个序列有序。

```c++
template<class T>
void select_sort(T* a, int left, int right)
{
	int i, j, min;
	for (i = left; i < right; i++)//从第一个到第n-1个位置
	{
		min = i;
		for (j = i + 1; j <= right; j++)
			//选择该位置及之后所有位置中最小值的下标
			if (a[j] < a[min])min = j;
		exch(a + i, a + min);//和i位置交换
	}
}
```

​		下面分析选择排序的复杂度：在第$i$次选择的过程中，需要 $n-i-1$次比较，一共需要 $\frac{n\times(n-1)}{2}$ 次比较。总共需要移动0次到$(n-1)$次移动。时间复杂度为$O(n^2)$的。

​		选择排序的方法有一下几个特性：首先，其**排序性能和序列的特性几乎无关**——不论序列初始情况如何，决定选择排序性能的比较过程都不可能省去；第二，选择排序有其特别适用的场景，其对于**元素规模很大**但是**关键字规模很小**的序列有较好的效率。这是因为选择排序的交换次数很少，不会涉及对规模很大的元素的重复交换；第三，选择排序是一种**不稳定**的排序方法。下面是一个例子：

<p align="center">排序前：3(1)，3(2)，1 </p>

<p align="center">排序后：1，3(2)，3(1)</p>


这是因为选择排序允许发生非相邻元素之间的交换。


## 三、快速排序

​		最基本的快速排序在1960年被提出，在那之后，快速排序的各种改进版本不断出现。快速排序算法易于实现，代码结构紧凑简练，对于按照通常规律随机分布的输入序列来讲，其平均运行时间较之同类算法更少，收到了人们的青睐，得到了非常广泛的应用。

​		快速排序是分治策略的一个典型应用，其基本思路为：将待排序序列中的某个元素作为**划分元素**，按照该元素的关键字将整个序列划分为左右**两个子序列**，左侧序列元素的关键字都小于该元素的关键字，右侧序列元素的关键字都大于该元素的关键字——也即找到该元素在最终的有序序列中的正确位置。然后分别**对左右两个子序列做同样的操作**，最终就能得到有序的序列。

​		快速排序实现的框架如下：

```c++
//递归实现
template<class T>
void quick_sort(T* a, int left, int right)
{
	if (right <= left)return;
	int i = partition(a, left, right);
	quick_sort(a, left, i - 1);
	quick_sort(a, i + 1, right);
}
```

​		可以看到，**划分操作**是快速排序的基本操作。划分操作的实现需要两个指针。**i和j**指针分别指向待划分序列的第一个和最后一个元素，v为划分元素，不失一般性地选择v为序列的最后一个元素。左侧指针从序列的最**左边向中间扫描**，直到找到一个比划分元素大的元素；右侧指针j从最**右边向中间扫描**，直到找到一个比划分元素小的元素——交换这两个元素。然后i、j两个指针从上一步的停止位置继续向中间扫描，当i和j相遇，把这个元素和划分元素交换，划分完成。

```c++
//划分操作
template<class T>
int partition(T* a, int left, int right)//划分 返回划分位置
{
	int i = left - 1, j = right;
	MiddleOfThree(a, left, right);
	T e = a[right];
	while (1)
	{
		while (a[++i] <= e)if (i == right)break;
		while (e <= a[--j])if (j == left)break;
		if (i >= j)break;
		exch(a + i, a + j);
	}
	exch(a + i, a + right);
	return i;
}
```

​		分析其性能，可以发现快速排序是收到序列初始可能情况影响较大的排序算法。这是因为快速排序不能确保划分出的两个子问题的规模大体相当。用**递归树**来表示，快速排序划分出的树这可能是**一棵很不平衡的树**，每次选择出的划分元素并不处在中间的位置。这也就导致快速排序在最坏情况（对于已经有序的序列）下会退化成 $O(n^2)$ 的时间复杂度。

​		而在最好情况下，序列会被划分为 $log_2n$ 层，每层划分（交换比较次数）不会超过 $n$，拥有 $O(nlog_2n)$ 的时间复杂度。平均情况下快速排序有 $O(nlnn)$ 的时间复杂度。另外，由于快速排序用到了递归调用，其栈存储指针和参数会使用 $O(log_2n)$ 到 $O(n)$ 的额外空间。

​		快速排序是一种不稳定的排序算法，这也是因为在排序过程中会涉及到非相邻元素之间的交换。

​		基本的快速排序算法有很多改进方案。首先，为了改进其可能出现的不平衡的问题，可以才采用**选择中间元素**作为划分元素的方法。取序列最左端、中间和最右端元素，比较，选择这三个元素关键字位于中间的一个为划分元素，进行划分操作。

```c++
// 三数取中
template<class T>
void MiddleOfThree(T* a, int left, int right)
{
	int middle = (left + right) / 2;
	if (a[middle] > a[right])exch(a + middle, a + right);
	if (a[left] > a[right])exch(a + left, a + right);
	if (a[left] > a[middle])exch(a + left, a + middle);
	exch(a + middle, a + right);
}
```

​		当子序列规模较小时，如果仍采取递归调用、划分的话，会产生很多的额外时间、空间消耗，是一种浪费。可以选择采用直接插入排序，这是因为此时序列基本有序（大多数元素已经位于最终位置），接近插入排序的最好情况，效率很高。这是对快速排序的第二种改进方式。

​方案一：
```c++
if((r - l) < M) { insert_sort(a, l, r); return; }
```

方案二：
```c++
if ((r - l) < M) return;
```

​		这是一种常见的思维方式，**利用简单排序算法实现对高级排序算法的优化**。

## 四、归并排序

### 1.有序归并

​		归并是将两个或两个以上的**有序序列合并**成一个新的有序序列的过程。其中，二路归并就是将两个有序序列合并的过程。

​		二路归并算法的思路是，设置指针i和j分别为序列A和B的指针，设C为归并后新的有序序列，变量k表示向C存放位置的指针。指针i和j递增，比较A[i]和B[j]的大小，把二者中较小的存放在C[k]中，并移位。当i和j中有一个达到序列长度，就把剩余的部分复制到C中去。

​		一个适用于归并排序的二路归并算法如下：

```c++
template<class T>
void merge(T* a, int p1, int p2, int p3)//经过修正的
{
	long i, j, k;
	T* c = new T[p3 - p1 + 1];
	for (i = 0, j = 0, k = 0; k < p3 - p1+1; k++)
	{
		if (i == p2 - p1) { c[k] = a[p2+j]; j++; continue; }
		if (j == p3-p2+1) { c[k] = a[p1+i]; i++; continue; }
		if (a[p1 + i] <= a[p2 + j]) { c[k] = a[p1 + i]; i++; }
		else { c[k] = a[p2 + j]; j++; }
	}
	for (i = 0; i < p3-p1+1; i++)
	{
		a[p1+i] = c[i];
	}
	delete[] c;
}
```

​		这个函数的功能是把数组的两个连续部分 $a[p_1]$ ~ $a[p_2-1]$ 和 $a[p_2]$ ~ $a[p_3]$ 进行二路归并，并且将得到的有序序列保存在 $a[p_1]$ ~ $a[p_3]$。

​		
### 2.自底向上的归并排序

​		自底向上的归并排序的思路如下：首先将长度为n的序列看作**n个长度为1的有序序列**，先做两两归并，得到**长度为2**的有序序列。再两两归并，得到**长度为4**的有序序列，如此重复，最后就能得到长度为n的有序序列。考察自底向上的归并排序的归并树，可以发现这是一棵**完全二叉树**。

```c++
template<class T>
void merge_sort(T* a, int left, int right)
{
	int i, m;
	for (m = 1; m < right - left; m = m + m)//每次循环m翻倍
	{
		for (i = left; i <= right - m; i += m + m)
		{
			merge(a, i, i + m, min(i + m + m - 1, right));
		}
	}
}
```

​		对整个序列进行一遍归并操作的时间复杂度是 $O(n)$，需要归并的次数为 $\lfloor log_2n \rfloor$。因此，自底向上归并排序算法的时间复杂度为 $O(nlog_2n)$。自底向上的归并排序是一种高效的排序算法，而且其性能与序列的特性无关。

​		自底向上的归并排序算法的一个缺点是**占用的附加存储空间太多**。需要使用与序列航都n成正比的额外内存，用于存放每步二路归并的结果。如果使用到的二路归并算法是稳定的，那么自底向上归并排序算法也就是稳定的。

### 3.自顶向下的归并排序

​		自顶向下的归并排序基于分治法的思路，每次将待排序序列**划分为两个长度大致相等的子序列**进行归并，通过递归实现。不断进行递归调用，直到子序列的长度为1，之后逐步回退，在**回退的过程中进行归并**。

```c++
template<class T>
void merge_sort2(T* a, int left, int right)
{
	if (right <= left)return;//子序列的长度小于等于1
	int m = (left + right) / 2;//取中间位置
	merge_sort2(a, left, m);//左右分别递归排序
	merge_sort2(a, m + 1, right);
	merge(a, left, m+1, right);
}
```

​		自顶向下和自底向上的归并排序有非常类似的性能。时间复杂度同样为 $O(nlog_2n)$，运行时间与序列特性无关；同时，需要 $O(n)$ 的辅助空间，空间复杂度较高。自顶向下归并排序算法的稳定性同样取决于二路归并算法的稳定性。

### 4.基于链表实现的归并排序算法

​		在执行归并排序的过程中，对数据基本上是顺序访问的，因此归并排序成为了链表排序可选择的主要方法之一。

```c++
//链表结构单位
struct Node {
	int val;
	Node* next;
};

//node -- 链表表头
Node* MergeSort(Node* node) {
	//先判断链表长度是否大于1，小于1时无须排序
	if (node != NULL && node->next != NULL) {
		//运用快慢指针，找到链表的中间节点
		Node* fast = node->next;
		Node* slow = node;
		while (fast != NULL && fast->next != NULL) {
			fast = fast->next->next;
			slow = slow->next;
		}

		//将链表分成两部分进行分割
		Node* p1 = MergeSort(slow->next);
		slow->next = NULL;                 
		Node* p2 = MergeSort(node);
		//对两条子链进行归并
		Node* p0 = (Node*)malloc(sizeof(Node));
		Node* p = p0;
		while (p1 != NULL && p2 != NULL) {
			if (p1->val < p2->val) { p->next = p1; p1 = p1->next; }
			else { p->next = p2; p2 = p2->next; }
			p = p->next;
		}
		if (p1 != NULL) p->next = p1;
		if (p2 != NULL) p->next = p2;
		p = p0->next;free(p0);
		return p;
	}
	return node;
}
```

## 五、排序算法总结

图片